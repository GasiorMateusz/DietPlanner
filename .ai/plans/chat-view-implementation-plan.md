# View Implementation Plan: AI Chat Interface

## 1. Overview

The AI Chat Interface is a conversational view where dietitians iteratively refine meal plans generated by an AI assistant. After completing the startup form on the Dashboard, users are navigated to this view where they receive the first AI-generated meal plan proposal and can engage in a back-and-forth conversation to make corrections and improvements. The view displays the conversation history, manages the chat state, handles API calls for follow-up messages, and provides an "Accept and edit manually" button to transition the finalized plan to the editor view.

This view implements user story **US-009** (Iterative meal plan improvement in AI chat) and serves as the intermediate step between meal plan initialization (US-008) and manual editing (US-010, US-011).

## 2. View Routing

**Path**: `/app/create`

**Layout**: Uses `PrivateLayout` (Astro layout for authenticated views)

**Page File**: `src/pages/app/create.astro`

**Component**: `AIChatInterface` (React component with `client:load`)

**Navigation Flow**:

- Entry: From Dashboard → StartupFormDialog → Navigate to `/app/create` with session data
- Exit: Click "Accept and edit manually" → Navigate to `/app/editor` with plan data via state bridge

## 3. Component Structure

The view consists of a single main React component (`AIChatInterface`) with the following internal structure:

```
AIChatInterface (React)
├── Alert (shadcn/ui) - Permanently visible AI disclaimer
├── MessageHistory (internal) - Scrollable container for chat messages
│   └── MessageItem (internal) - Individual message bubble
│       ├── UserMessage (internal) - User prompt display
│       └── AssistantMessage (internal) - AI response display
├── MessageInput (internal) - Text input and send button
│   ├── Textarea (shadcn/ui) - Message input field
│   └── Button (shadcn/ui) - Send button
└── AcceptButton (internal) - Navigation to editor
    └── Button (shadcn/ui) - "Accept and edit manually" button
```

## 4. Component Details

### AIChatInterface

**Component Description**: Main container component for the AI chat interface. Manages all chat-related state, handles API calls for sending messages, displays the conversation history, and provides controls for user input and acceptance. This is a self-contained component that manages its entire lifecycle internally.

**Main Elements**:

- `<Alert>` with variant "default" or "destructive" for AI disclaimer (permanently visible)
- Scrollable container with `MessageHistory` div
- `MessageInput` form with Textarea and Send button
- `AcceptButton` at the bottom
- Loading indicator overlay or inline loading state

**Handled Events**:

- Component mount: Receives initial session data from Astro page props
- Form submit: On Send button click or Enter key (with Ctrl/Cmd modifier), submits user message to `POST /api/ai/sessions/{id}/message`
- Accept click: On "Accept and edit manually" button, stores final plan data in client-side bridge variable and navigates to `/app/editor`
- Window resize: Manages scrolling to bottom of message history
- Network errors: Handles retry logic for failed API calls

**Handled Validation**:

- Message input validation: Non-empty string required (trim whitespace)
- Minimum length: At least 1 character after trimming
- Maximum length: Configurable limit (e.g., 5000 characters)
- Session ID validation: Must be a valid UUID format
- Button disable states: Send button disabled when loading or empty input, Accept button always enabled

**Types**:

- Props: `AIChatInterfaceProps` (receives sessionId and initialMessage from page)
- State: `ChatState` (messageHistory, isLoading, error, promptCount)
- DTOs: `SendAiMessageCommand`, `SendAiMessageResponseDto`

**Props**:

```typescript
interface AIChatInterfaceProps {
  sessionId: string; // UUID of the AI chat session
  initialMessage: AssistantChatMessage; // First AI response from POST /api/ai/sessions
}
```

### MessageHistory

**Component Description**: Internal rendering area for chat messages. Displays all messages in chronological order with appropriate styling to distinguish user messages from assistant messages.

**Main Elements**:

- Scrollable container div with overflow handling
- Conditional rendering of `MessageItem` components
- Empty state when no messages (should not occur after mount)

**Handled Events**:

- Auto-scroll to bottom when new messages arrive (useRef and useEffect)
- Scroll position preservation on window resize

**Handled Validation**:

- None (presentation-only component)

**Types**:

- Props: `{ messages: ChatMessage[] }`

**Props**: Receives messageHistory array from parent AIChatInterface

### MessageItem

**Component Description**: Individual message bubble component. Renders either a user or assistant message with appropriate styling and formatting.

**Main Elements**:

- Conditional rendering based on `message.role`
- User messages: Right-aligned, distinct color scheme
- Assistant messages: Left-aligned, distinct color scheme
- Pre-formatted text container for message content

**Handled Events**:

- None (presentation-only)

**Handled Validation**:

- None (assumes valid ChatMessage type)

**Types**:

- Props: `{ message: ChatMessage }`

**Props**: Single ChatMessage object from messageHistory

### MessageInput

**Component Description**: Form input area for composing and sending new messages to the AI.

**Main Elements**:

- Form element wrapping input controls
- `<Textarea>` from shadcn/ui for message composition
- `<Button>` from shadcn/ui with disabled state and loading indicator
- Optional character counter

**Handled Events**:

- Form submit: Prevent default, validate input, call parent submit handler
- Enter key: Submit if Ctrl/Cmd modifier held, otherwise allow newline
- Input change: Update controlled input value
- Button click: Trigger form submit

**Handled Validation**:

- Non-empty input required (trim whitespace before validation)
- Maximum length enforcement with visual feedback
- Disable submit during loading state

**Types**:

- Props: `{ onSubmit: (message: string) => void; isLoading: boolean; disabled?: boolean }`

**Props**: Callback from AIChatInterface parent, loading state, optional disabled prop

### AcceptButton

**Component Description**: Primary action button for accepting the current meal plan and transitioning to the editor.

**Main Elements**:

- `<Button>` from shadcn/ui with "default" variant
- Icon (optional) to indicate navigation
- Loading state (optional) if transition requires async operations

**Handled Events**:

- Click: Extract final plan from last assistant message, store in bridge variable, navigate to `/app/editor`

**Handled Validation**:

- Ensure at least one assistant message exists
- Ensure user has not already accepted (optional guard)

**Types**:

- Props: `{ onAccept: () => void; disabled?: boolean }`

**Props**: Callback from AIChatInterface parent, optional disabled state

## 5. Types

### Existing DTOs (from types.ts)

**ChatMessage**: Union type representing any message in the conversation

```typescript
type ChatMessage = UserChatMessage | AssistantChatMessage;
```

**UserChatMessage**: User prompt structure

```typescript
type UserChatMessage = {
  role: "user";
  content: string; // User's message text
};
```

**AssistantChatMessage**: AI response structure

```typescript
type AssistantChatMessage = {
  role: "assistant";
  content: string; // AI's response text (contains the meal plan)
};
```

**SendAiMessageCommand**: Request payload for POST /api/ai/sessions/{id}/message

```typescript
type SendAiMessageCommand = {
  message: UserChatMessage; // The user's follow-up message
};
```

**SendAiMessageResponseDto**: Response from POST /api/ai/sessions/{id}/message

```typescript
type SendAiMessageResponseDto = {
  session_id: string; // UUID of the chat session
  message: AssistantChatMessage; // New AI response
  prompt_count: number; // Total number of prompts sent (telemetry)
};
```

**CreateAiSessionResponseDto**: Response from POST /api/ai/sessions (used for initial data)

```typescript
type CreateAiSessionResponseDto = {
  session_id: string; // UUID of the chat session
  message: AssistantChatMessage; // First AI response
  prompt_count: number; // Initial prompt count (always 1)
};
```

### ViewModel Types (component-specific)

**AIChatInterfaceProps**: Props for the main component

```typescript
interface AIChatInterfaceProps {
  sessionId: string; // UUID from CreateAiSessionResponseDto
  initialMessage: AssistantChatMessage; // From CreateAiSessionResponseDto
}
```

**ChatState**: Internal state structure

```typescript
interface ChatState {
  messageHistory: ChatMessage[]; // All messages in the conversation
  isLoading: boolean; // True when sending a message
  error: string | null; // Error message for display
  promptCount: number; // Current prompt count from API
}
```

**StateBridge**: Client-side bridge for passing data to editor

```typescript
interface StateBridge {
  sessionId: string; // For linking saved meal plan to chat session
  lastAssistantMessage: string; // Contains the final meal plan content
  startupData?: MealPlanStartupData; // Initial form data (optional, for reference)
}
```

### MealPlanStartupData (referenced, from types.ts)

Used for storing startup data in state bridge if needed for editor context.

```typescript
type MealPlanStartupData = {
  patient_age: number | null;
  patient_weight: number | null;
  patient_height: number | null;
  activity_level: "sedentary" | "light" | "moderate" | "high" | null;
  target_kcal: number | null;
  target_macro_distribution: TargetMacroDistribution | null;
  meal_names: string | null;
  exclusions_guidelines: string | null;
};
```

## 6. State Management

The view uses React's built-in `useState` hook for local state management. No global state manager (Redux, Zustand, etc.) is required for this view.

### State Variables

1. **messageHistory** (`ChatMessage[]`): Array of all messages in the conversation
   - Initialized with the `initialMessage` from props
   - Updated when new messages are received from API
   - Used to render the conversation history

2. **isLoading** (`boolean`): Loading state indicator
   - Set to true when sending a message to the API
   - Set to false when the API call completes (success or error)
   - Used to disable the Send button and show loading indicator

3. **error** (`string | null`): Error message for display
   - Set when an API call fails
   - Cleared when a new message is sent or on retry
   - Displayed as an Alert component with "destructive" variant

4. **promptCount** (`number`): Current prompt count from telemetry
   - Initialized from props (initial value: 1)
   - Updated from each API response
   - Can be displayed in UI for transparency (optional)

5. **inputValue** (`string`): Controlled input value for message composition
   - Bound to the Textarea component
   - Cleared after successful message submission
   - Used for validation before submission

### Custom Hooks

None required for this view. All state is managed within the `AIChatInterface` component using standard React hooks.

### State Bridge (Client-side)

A simple client-side variable or sessionStorage is used to transfer data from the chat view to the editor view upon acceptance.

**Option 1: Window-level variable**

```typescript
// In AIChatInterface onAccept handler
(window as any).mealPlanBridge = {
  sessionId,
  lastAssistantMessage: messageHistory[messageHistory.length - 1].content,
};
```

**Option 2: sessionStorage**

```typescript
// In AIChatInterface onAccept handler
sessionStorage.setItem(
  "mealPlanBridge",
  JSON.stringify({
    sessionId,
    lastAssistantMessage: messageHistory[messageHistory.length - 1].content,
  })
);
```

The editor view will read from this bridge on mount.

### State Persistence

- No long-term persistence is required for this view
- Refresh or navigation away will lose the conversation (by design)
- The `sessionId` and conversation are stored in the backend database for telemetry

## 7. API Integration

### Endpoint: POST /api/ai/sessions/{id}/message

**Purpose**: Send a follow-up message in an existing AI chat session and receive an updated meal plan.

**Request**:

- **Method**: POST
- **URL**: `/api/ai/sessions/{sessionId}/message`
- **Headers**:
  - `Content-Type: application/json`
  - `Authorization: Bearer <SUPABASE_JWT>` (handled automatically by Astro middleware)
- **Body**:

```typescript
SendAiMessageCommand = {
  message: {
    role: "user",
    content: string, // User's message text
  },
};
```

**Response Success (200 OK)**:

```typescript
SendAiMessageResponseDto = {
  session_id: string, // UUID of the chat session
  message: {
    role: "assistant",
    content: string, // AI's updated meal plan
  },
  prompt_count: number, // Total prompts sent (telemetry)
};
```

**Response Errors**:

- **401 Unauthorized**: User not authenticated → Redirect to `/login`
- **404 Not Found**: Chat session not found → Display error message, allow retry or navigation back
- **502 Bad Gateway**: OpenRouter API error → Display error message, allow retry
- **500 Internal Server Error**: Database or server error → Display error message, allow retry
- **400 Bad Request**: Validation error → Display validation details (should not occur with proper frontend validation)

### API Call Implementation

The API call is implemented using the native `fetch` API:

```typescript
async function sendMessage(sessionId: string, message: UserChatMessage): Promise<SendAiMessageResponseDto> {
  const response = await fetch(`/api/ai/sessions/${sessionId}/message`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify({ message }),
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.error || "Failed to send message");
  }

  return response.json();
}
```

### Error Handling

Errors are caught in the component's submit handler and displayed to the user via an Alert component. Users can retry failed requests by clicking Send again.

**401 Unauthorized** triggers a global redirect to `/login` (handled by middleware or global error handler).

**Network errors** (502, 503, 504) are considered temporary and allow retry.

**404 Not Found** indicates the session may have expired or been deleted and suggests returning to the dashboard.

## 8. User Interactions

### Interaction 1: View Initialization

**User Action**: Page loads or navigates to `/app/create`

**System Response**:

1. React component mounts with props (`sessionId`, `initialMessage`)
2. State is initialized with the first assistant message
3. UI renders:
   - AI disclaimer Alert at the top
   - Message history showing the first AI response
   - Empty message input field at the bottom
   - "Accept and edit manually" button enabled

**Expected Outcome**: User sees the first AI-generated meal plan and can start interacting

### Interaction 2: Send Follow-up Message

**User Action**: User types a message in the Textarea and clicks "Send" or presses Ctrl/Cmd+Enter

**System Response**:

1. Validate input (non-empty, within length limits)
2. If valid:
   - Disable Send button
   - Set loading state to true
   - Add user message to messageHistory (optimistic update)
   - Call `POST /api/ai/sessions/{id}/message` with user message
   - On success:
     - Add assistant response to messageHistory
     - Clear input field
     - Update promptCount
     - Set loading to false
     - Scroll to bottom of message history
   - On error:
     - Remove optimistic user message
     - Display error Alert
     - Set loading to false
     - Allow user to retry

**Expected Outcome**: User sees their message and the AI's updated response in the conversation

### Interaction 3: Accept and Navigate to Editor

**User Action**: User clicks "Accept and edit manually" button

**System Response**:

1. Extract the last assistant message from messageHistory
2. Store sessionId and message content in client-side bridge variable
3. Navigate to `/app/editor` (no ID parameter)
4. Editor component reads from bridge and populates form

**Expected Outcome**: User is taken to the editor with the AI-generated content ready for manual editing

### Interaction 4: Handle Network Error

**User Action**: API call fails (502, 503, 504, network error)

**System Response**:

1. Catch error in API call handler
2. Display error Alert with message: "AI service unavailable. Please try again."
3. Keep user's input in the Textarea (not cleared)
4. Enable Send button for retry
5. Maintain conversation history (no rollback)

**Expected Outcome**: User sees error message and can retry sending the message

### Interaction 5: Scroll and View History

**User Action**: User scrolls through conversation history

**System Response**:

1. Auto-scroll on new messages (if user is at the bottom)
2. Preserve scroll position if user has scrolled up
3. Show message bubbles with appropriate styling

**Expected Outcome**: User can view the full conversation history and see new messages as they arrive

## 9. Conditions and Validation

### Client-Side Validation

#### Message Input Validation

**Component**: MessageInput

**Conditions**:

1. **Non-empty requirement**: After trimming whitespace, message must contain at least 1 character
   - Validation triggers on form submit
   - Visual feedback: Send button remains disabled if empty
   - Error message: None (button state provides feedback)

2. **Maximum length**: Message content cannot exceed configurable maximum (default: 5000 characters)
   - Validation triggers on input change (real-time)
   - Visual feedback: Character counter with warning color if approaching limit
   - Error message: "Message too long" if exceeding limit

3. **Loading state**: Input is disabled while a message is being sent
   - Prevents duplicate submissions
   - Visual feedback: Disabled Textarea and button

#### Session State Validation

**Component**: AIChatInterface

**Conditions**:

1. **Session ID format**: Must be a valid UUID
   - Validated on component props
   - Error handling: Display error if invalid on mount
   - Resolution: Redirect to dashboard if invalid

2. **Initial message presence**: At least one assistant message must exist
   - Validated on component props
   - Error handling: Display "No session data" error
   - Resolution: Redirect to dashboard

3. **Accept button availability**: Button is only enabled if there is at least one assistant message
   - Always true after initial mount (by design)
   - Visual feedback: Button disabled state

### Server-Side Validation

Server-side validation is handled by the API endpoint and returns appropriate error responses. The frontend must handle these responses gracefully.

**Validation performed by API**:

1. Session ID must exist in database and belong to the authenticated user
2. Message object must have valid structure (`role: 'user'`, `content: string`)
3. User must be authenticated (handled by middleware)

**Frontend handling**:

- 400 Bad Request: Should not occur with proper validation, but display general error
- 401 Unauthorized: Trigger global redirect to `/login`
- 404 Not Found: Display "Session not found" error and suggest returning to dashboard
- 502 Bad Gateway: Display "AI service unavailable" error with retry option

### UI State Conditions

1. **Loading State**: Send button disabled, loading spinner shown
2. **Error State**: Error Alert displayed, Send button enabled for retry
3. **Empty State**: Should not occur, as component requires initial message on mount
4. **Success State**: Default state, messages displayed, input ready for next message

## 10. Error Handling

### Error Types and Handling

#### Network Errors

**Errors**: Fetch network failures, timeout, DNS resolution failure

**Handling**:

- Display user-friendly error message: "Network error. Please check your connection and try again."
- Preserve user's input in the Textarea
- Allow immediate retry
- Don't modify conversation history

**UI**: Alert with "destructive" variant

#### API Error Responses

**401 Unauthorized**:

- Cause: User session expired or invalid
- Handling: Trigger global redirect to `/login` page
- UI: No error message shown (redirect occurs)

**404 Not Found**:

- Cause: Chat session deleted or never existed
- Handling: Display error: "Session not found. Please start a new meal plan from the dashboard."
- UI: Alert with suggestion to return to dashboard
- Action: Provide link back to `/app/dashboard`

**502 Bad Gateway**:

- Cause: OpenRouter AI service unavailable or returned error
- Handling: Display error: "AI service is temporarily unavailable. Please try again in a moment."
- UI: Alert with retry button
- Action: Allow user to retry without losing their message

**500 Internal Server Error**:

- Cause: Database error or unexpected server failure
- Handling: Display error: "An internal error occurred. Please try again later."
- UI: Alert with retry option
- Action: Allow retry, consider logging error for debugging

**400 Bad Request**:

- Cause: Validation error in request payload (should not occur with proper frontend validation)
- Handling: Display error: "Invalid request. Please try again."
- UI: Alert
- Action: Allow retry after user manually fixes input

#### State Errors

**Invalid Props**:

- Cause: Missing or invalid sessionId or initialMessage
- Handling: Display "Invalid session data" error on mount
- UI: Alert with suggestion to return to dashboard
- Action: Provide navigation back to `/app/dashboard`

**Empty Message History**:

- Cause: State corruption or unexpected behavior
- Handling: Display "No messages available" error
- UI: Alert
- Action: Suggest starting a new meal plan

### Error Recovery

All recoverable errors (502, 500, network) allow the user to retry by clicking "Send" again. The error message is cleared when a new message is sent or when the user starts typing.

Non-recoverable errors (401, 404, invalid props) either redirect the user or provide clear messaging with navigation options.

### Error Logging

Errors should be logged for debugging purposes:

```typescript
console.error("AI Chat error:", {
  sessionId,
  errorMessage: error.message,
  errorDetails: error,
  timestamp: new Date().toISOString(),
});
```

In production, consider sending errors to an error tracking service (e.g., Sentry).

## 11. Implementation Steps

### Step 1: Create Astro Page

Create `src/pages/app/create.astro`:

1. Import `PrivateLayout` from `../../layouts/PrivateLayout.astro`
2. Import `AIChatInterface` React component
3. Get initial session data from props (passed from Dashboard after startup form submission)
4. Render `AIChatInterface` with `client:load` directive
5. Pass `sessionId` and `initialMessage` as props

### Step 2: Create Main React Component

Create `src/components/AIChatInterface.tsx`:

1. Define `AIChatInterfaceProps` interface
2. Set up state variables using `useState`:
   - `messageHistory: ChatMessage[]`
   - `isLoading: boolean`
   - `error: string | null`
   - `promptCount: number`
   - `inputValue: string`
3. Initialize state from props on mount
4. Implement `sendMessage` API call function
5. Implement `handleSubmit` form handler
6. Implement `handleAccept` navigation handler
7. Set up auto-scroll effect with `useEffect` and `useRef`

### Step 3: Create Message Display Components

Within `AIChatInterface.tsx` or separate files:

1. Create `MessageHistory` component to render scrollable message list
2. Create `MessageItem` component to render individual message bubbles
3. Style user vs assistant messages differently
4. Implement auto-scroll to bottom on new messages

### Step 4: Create Message Input Component

Create `MessageInput` component (within `AIChatInterface.tsx` or separate):

1. Create form with Textarea and Button
2. Implement controlled input with validation
3. Handle Enter key with Ctrl/Cmd modifier for submission
4. Implement loading and disabled states
5. Add optional character counter

### Step 5: Add AI Disclaimer Alert

In `AIChatInterface.tsx`:

1. Add Alert component at the top of the view
2. Use default or info variant
3. Display disclaimer text: "This content is AI-generated. Please verify all information before using with patients."
4. Keep Alert visible and non-dismissible

### Step 6: Implement Accept Button

In `AIChatInterface.tsx`:

1. Add "Accept and edit manually" button at the bottom
2. Implement `handleAccept` to:
   - Extract last assistant message
   - Store in client-side bridge (window variable or sessionStorage)
   - Navigate to `/app/editor`
3. Style button as primary action

### Step 7: Implement Error Handling

In `AIChatInterface.tsx`:

1. Add error Alert component
2. Implement error catching in API call
3. Map error types to user-friendly messages
4. Implement retry logic
5. Handle 401 redirect (via middleware or global handler)

### Step 8: Add Styling and Polish

Using Tailwind CSS:

1. Style message bubbles (user right, assistant left)
2. Implement loading spinner in Send button
3. Style error Alert with destructive variant
4. Ensure responsive design
5. Add smooth scrolling behavior
6. Style Accept button prominently

### Step 9: Implement State Bridge

Create bridge mechanism for editor handoff:

1. Choose bridge method (window variable or sessionStorage)
2. In `handleAccept`: store sessionId and lastAssistantMessage
3. Document bridge interface for editor implementation
4. Consider bridge cleanup (clear after editor reads it)

### Step 10: Testing

Test all interactions:

1. Initialize view with valid session data
2. Send multiple follow-up messages
3. Handle network errors
4. Handle API errors (502, 404, 401)
5. Verify Accept navigation to editor
6. Test auto-scroll behavior
7. Test responsive design
8. Validate input constraints

### Step 11: Integration Testing

Test end-to-end flow:

1. Dashboard → StartupForm → Create view → Editor view
2. Multiple iterations in chat
3. Error recovery scenarios
4. State preservation during errors
5. Navigation away and back behavior

### Step 12: Documentation

Add JSDoc comments to:

1. Main component
2. All internal components
3. API call functions
4. Event handlers
5. State bridge interface

Document:

1. Props interface
2. State structure
3. Error handling approach
4. Integration with other views
